name: "repo-audit"
description: "Audit a single Amplifier ecosystem repository for compliance with Microsoft standards and Amplifier guidelines."
version: "1.2.0"
author: "Amplifier Team"
tags: ["audit", "compliance", "github", "amplifier"]

# Single Repository Audit Recipe
#
# Checks a repository against Amplifier ecosystem standards:
# - Listed in MODULES.md for discoverability
# - Required Microsoft boilerplate files (CODE_OF_CONDUCT.md, SECURITY.md, SUPPORT.md, LICENSE)
# - README.md has Contributing and Trademarks sections (verbatim from template)
# - GitHub Issues status (recommendation to disable for non-main repos)
# - Repository stats (open PRs, activity)
#
# Usage:
#   # Basic audit
#   amplifier recipes execute repo-audit.yaml --context '{"repo_name": "amplifier-core"}'
#
#   # Audit with fix PR creation
#   amplifier recipes execute repo-audit.yaml --context '{
#     "repo_name": "amplifier-module-tool-web",
#     "create_fix_pr": "true"
#   }'
#
#   # Audit a non-Microsoft repo
#   amplifier recipes execute repo-audit.yaml --context '{
#     "repo_owner": "robotdad",
#     "repo_name": "amplifier-app-transcribe"
#   }'
#
# Requirements:
#   - gh CLI installed and authenticated
#   - Write access to the repo if create_fix_pr is "true"

recursion:
  max_depth: 2
  max_total_steps: 50

context:
  # Repository to audit
  repo_owner: "microsoft"
  repo_name: ""
  
  # Whether to create PRs for fixable issues (use string "true"/"false" for condition compatibility)
  create_fix_pr: "false"
  
  # Dry-run mode: show what WOULD happen without actually creating PRs
  # When "true", prepares fixes and shows PR preview but doesn't push/create
  dry_run: "false"
  
  # Working directory for intermediate files
  working_dir: "./ai_working/repo-audit"
  
  # Reference content location (amplifier-core as source of truth)
  reference_repo: "microsoft/amplifier-core"

steps:
  # ==========================================================================
  # STEP 1: Setup and Validate Repository
  # ==========================================================================
  - id: "setup"
    type: "bash"
    command: |
      set -euo pipefail
      mkdir -p "{{working_dir}}/{{repo_name}}"
      mkdir -p "{{working_dir}}/reference"
      echo "Working directory created: {{working_dir}}/{{repo_name}}"
    output: "setup_result"
    timeout: 30

  - id: "fetch-repo-info"
    type: "bash"
    command: |
      gh repo view "{{repo_owner}}/{{repo_name}}" --json name,owner,description,hasIssuesEnabled,hasWikiEnabled,isArchived,defaultBranchRef,pushedAt,url 2>&1 || echo '{"error": "Repository not found or not accessible"}'
    output: "repo_info_raw"
    timeout: 60
    retry:
      max_attempts: 3
      backoff: "exponential"
      initial_delay: 5
    on_error: "continue"
    output_exit_code: "repo_fetch_code"

  - id: "validate-repo"
    type: "bash"
    parse_json: true
    command: |
      # Check if repo fetch was successful
      # Use heredoc to safely handle JSON with special characters (quotes, apostrophes)
      cat << 'REPO_INFO_EOF' > /tmp/repo_info_$$.json
      {{repo_info_raw}}
      REPO_INFO_EOF
      
      if jq -e '.error' /tmp/repo_info_$$.json > /dev/null 2>&1; then
        echo '{"valid": false, "error": "Repository not found or not accessible"}'
      elif jq -e '.isArchived' /tmp/repo_info_$$.json | grep -q 'true'; then
        echo '{"valid": false, "error": "Repository is archived"}'
      else
        jq '{valid: true, name: .name, description: .description, issues_enabled: .hasIssuesEnabled, last_push: .pushedAt}' /tmp/repo_info_$$.json
      fi
      rm -f /tmp/repo_info_$$.json
    output: "repo_validation"
    timeout: 30

  # ==========================================================================
  # STEP 2: Check MODULES.md Listing
  # ==========================================================================
  - id: "fetch-modules-md"
    type: "bash"
    command: |
      curl -sL --retry 3 --retry-delay 2 "https://raw.githubusercontent.com/microsoft/amplifier/main/docs/MODULES.md" > "{{working_dir}}/MODULES.md"
      if [ -s "{{working_dir}}/MODULES.md" ]; then
        echo "Fetched MODULES.md ($(wc -c < "{{working_dir}}/MODULES.md") bytes)"
      else
        echo "ERROR: Failed to fetch MODULES.md"
        exit 1
      fi
    output: "modules_fetch_result"
    timeout: 60
    retry:
      max_attempts: 3
      backoff: "exponential"
      initial_delay: 5

  - id: "check-modules-listing"
    type: "bash"
    parse_json: true
    command: |
      REPO_NAME="{{repo_name}}"
      MODULES_FILE="{{working_dir}}/MODULES.md"
      
      # Search for the repo name in MODULES.md
      if grep -q "$REPO_NAME" "$MODULES_FILE"; then
        # Check if it's in a table row (proper listing) or a link
        if grep -E "\|\s*\*\*$REPO_NAME\*\*|\[$REPO_NAME\]|$REPO_NAME\s*\|" "$MODULES_FILE" > /dev/null; then
          echo '{"listed": true, "finding": "Repository is properly listed in MODULES.md", "severity": "pass"}'
        else
          echo '{"listed": true, "finding": "Repository name appears in MODULES.md but may not be properly listed in a table", "severity": "warning"}'
        fi
      else
        echo '{"listed": false, "finding": "Repository is NOT listed in MODULES.md - recommend adding for discoverability", "severity": "recommendation"}'
      fi
    output: "modules_listing"
    timeout: 30

  # ==========================================================================
  # STEP 3: Fetch Reference Boilerplate Files
  # ==========================================================================
  - id: "fetch-reference-files"
    type: "bash"
    command: |
      set -euo pipefail
      REF_DIR="{{working_dir}}/reference"
      BASE_URL="https://raw.githubusercontent.com/{{reference_repo}}/main"
      
      echo "Fetching reference boilerplate files from {{reference_repo}}..."
      
      for file in CODE_OF_CONDUCT.md SECURITY.md SUPPORT.md LICENSE README.md; do
        curl -sL --retry 3 --retry-delay 2 "$BASE_URL/$file" > "$REF_DIR/$file"
        if [ -s "$REF_DIR/$file" ]; then
          echo "$file: fetched ($(wc -c < "$REF_DIR/$file") bytes)"
        else
          echo "$file: WARNING - empty or failed"
        fi
      done
      
      echo "Reference files fetch complete"
    output: "reference_fetch_result"
    timeout: 120
    retry:
      max_attempts: 2
      backoff: "linear"
      initial_delay: 5

  # ==========================================================================
  # STEP 4: Fetch Target Repository Files
  # ==========================================================================
  - id: "fetch-target-files"
    type: "bash"
    command: |
      TARGET_DIR="{{working_dir}}/{{repo_name}}"
      BASE_URL="https://raw.githubusercontent.com/{{repo_owner}}/{{repo_name}}/main"
      
      echo "Fetching files from {{repo_owner}}/{{repo_name}}..."
      
      for file in CODE_OF_CONDUCT.md SECURITY.md SUPPORT.md LICENSE README.md; do
        HTTP_CODE=$(curl -sL --retry 2 -w "%{http_code}" -o "$TARGET_DIR/$file" "$BASE_URL/$file")
        if [ "$HTTP_CODE" = "200" ] && [ -s "$TARGET_DIR/$file" ]; then
          echo "$file: found ($(wc -c < "$TARGET_DIR/$file") bytes)"
        else
          echo "$file: NOT FOUND (HTTP $HTTP_CODE)"
          rm -f "$TARGET_DIR/$file"
        fi
      done
    output: "target_fetch_result"
    timeout: 120

  # ==========================================================================
  # STEP 5: Compare Boilerplate Files
  # ==========================================================================
  - id: "compare-boilerplate"
    type: "bash"
    parse_json: true
    command: |
      REF_DIR="{{working_dir}}/reference"
      TARGET_DIR="{{working_dir}}/{{repo_name}}"
      
      # Initialize results
      results='{"files": [], "all_pass": true}'
      
      for file in CODE_OF_CONDUCT.md SECURITY.md SUPPORT.md LICENSE; do
        if [ ! -f "$TARGET_DIR/$file" ]; then
          results=$(echo "$results" | jq --arg file "$file" '.files += [{"name": $file, "status": "missing", "match": false, "severity": "error"}] | .all_pass = false')
        elif diff -q "$REF_DIR/$file" "$TARGET_DIR/$file" > /dev/null 2>&1; then
          results=$(echo "$results" | jq --arg file "$file" '.files += [{"name": $file, "status": "present", "match": true, "severity": "pass"}]')
        else
          results=$(echo "$results" | jq --arg file "$file" '.files += [{"name": $file, "status": "present", "match": false, "severity": "error"}] | .all_pass = false')
        fi
      done
      
      echo "$results"
    output: "boilerplate_check"
    timeout: 60

  # ==========================================================================
  # STEP 6: Check README Contributing and Trademarks Sections
  # ==========================================================================
  - id: "check-readme-sections"
    type: "bash"
    parse_json: true
    command: |
      REF_DIR="{{working_dir}}/reference"
      TARGET_DIR="{{working_dir}}/{{repo_name}}"
      TARGET_README="$TARGET_DIR/README.md"
      REF_README="$REF_DIR/README.md"
      
      # Check if README exists
      if [ ! -f "$TARGET_README" ]; then
        echo '{"readme_exists": false, "contributing_section": false, "trademarks_section": false, "contributing_verbatim": false, "trademarks_verbatim": false, "severity": "error", "finding": "README.md is missing"}'
        exit 0
      fi
      
      # Get line numbers for sections in reference
      CONTRIB_START=$(grep -n "^## Contributing" "$REF_README" | head -1 | cut -d: -f1 || echo "")
      TRADE_START=$(grep -n "^## Trademarks" "$REF_README" | head -1 | cut -d: -f1 || echo "")
      
      # Check if target has the sections
      HAS_CONTRIB=$(grep -c "^## Contributing" "$TARGET_README" 2>/dev/null || echo "0")
      HAS_TRADE=$(grep -c "^## Trademarks" "$TARGET_README" 2>/dev/null || echo "0")
      
      CONTRIB_MATCH="false"
      TRADE_MATCH="false"
      
      # Compare Contributing sections
      if [ "$HAS_CONTRIB" -gt 0 ] && [ -n "$CONTRIB_START" ] && [ -n "$TRADE_START" ]; then
        sed -n "${CONTRIB_START},$((TRADE_START-1))p" "$REF_README" > /tmp/ref_contrib.txt
        
        TARGET_CONTRIB_START=$(grep -n "^## Contributing" "$TARGET_README" | head -1 | cut -d: -f1)
        TARGET_NEXT=$(tail -n +$((TARGET_CONTRIB_START+1)) "$TARGET_README" | grep -n "^## " | head -1 | cut -d: -f1 || echo "")
        
        if [ -n "$TARGET_NEXT" ]; then
          sed -n "${TARGET_CONTRIB_START},$((TARGET_CONTRIB_START+TARGET_NEXT-1))p" "$TARGET_README" > /tmp/target_contrib.txt
        else
          tail -n +$TARGET_CONTRIB_START "$TARGET_README" > /tmp/target_contrib.txt
        fi
        
        if diff -q /tmp/ref_contrib.txt /tmp/target_contrib.txt > /dev/null 2>&1; then
          CONTRIB_MATCH="true"
        fi
      fi
      
      # Compare Trademarks sections
      if [ "$HAS_TRADE" -gt 0 ] && [ -n "$TRADE_START" ]; then
        tail -n +$TRADE_START "$REF_README" > /tmp/ref_trade.txt
        
        TARGET_TRADE_START=$(grep -n "^## Trademarks" "$TARGET_README" | head -1 | cut -d: -f1)
        tail -n +$TARGET_TRADE_START "$TARGET_README" > /tmp/target_trade.txt
        
        if diff -q /tmp/ref_trade.txt /tmp/target_trade.txt > /dev/null 2>&1; then
          TRADE_MATCH="true"
        fi
      fi
      
      # Determine overall severity
      if [ "$HAS_CONTRIB" -eq 0 ] || [ "$HAS_TRADE" -eq 0 ]; then
        SEVERITY="error"
        FINDING="README.md is missing required sections"
      elif [ "$CONTRIB_MATCH" = "false" ] || [ "$TRADE_MATCH" = "false" ]; then
        SEVERITY="warning"
        FINDING="README.md sections exist but content differs from template"
      else
        SEVERITY="pass"
        FINDING="README.md has correct Contributing and Trademarks sections"
      fi
      
      jq -n \
        --argjson readme_exists true \
        --argjson has_contrib "$([ "$HAS_CONTRIB" -gt 0 ] && echo true || echo false)" \
        --argjson has_trade "$([ "$HAS_TRADE" -gt 0 ] && echo true || echo false)" \
        --argjson contrib_match "$CONTRIB_MATCH" \
        --argjson trade_match "$TRADE_MATCH" \
        --arg severity "$SEVERITY" \
        --arg finding "$FINDING" \
        '{
          readme_exists: $readme_exists,
          contributing_section: $has_contrib,
          trademarks_section: $has_trade,
          contributing_verbatim: $contrib_match,
          trademarks_verbatim: $trade_match,
          severity: $severity,
          finding: $finding
        }'
    output: "readme_check"
    timeout: 60

  # ==========================================================================
  # STEP 7: Check GitHub Issues Status
  # ==========================================================================
  - id: "check-issues-status"
    type: "bash"
    parse_json: true
    command: |
      # Get issues enabled status from repo validation
      # Use heredoc to safely handle JSON with special characters
      cat << 'REPO_JSON_EOF' > /tmp/repo_issues_$$.json
      {{repo_info_raw}}
      REPO_JSON_EOF
      
      # NOTE: Use 'has()' check + 'tostring' because jq '//' operator treats false as falsy
      ISSUES_ENABLED=$(jq -r 'if has("hasIssuesEnabled") then (.hasIssuesEnabled | tostring) else "unknown" end' /tmp/repo_issues_$$.json)
      rm -f /tmp/repo_issues_$$.json
      
      # Special case: main amplifier repo SHOULD have issues enabled
      if [ "{{repo_name}}" = "amplifier" ] && [ "{{repo_owner}}" = "microsoft" ]; then
        if [ "$ISSUES_ENABLED" = "true" ]; then
          jq -n '{issues_enabled: true, severity: "pass", finding: "GitHub Issues are enabled (correct for main amplifier repo)"}'
        else
          jq -n '{issues_enabled: false, severity: "warning", finding: "GitHub Issues are disabled - main amplifier repo should have issues enabled"}'
        fi
      else
        # Other repos: recommend disabling issues
        if [ "$ISSUES_ENABLED" = "false" ]; then
          jq -n '{issues_enabled: false, severity: "pass", finding: "GitHub Issues are disabled (recommended for non-main repos)"}'
        elif [ "$ISSUES_ENABLED" = "true" ]; then
          jq -n '{issues_enabled: true, severity: "recommendation", finding: "GitHub Issues are enabled - recommend disabling to funnel issues to main amplifier repo"}'
        else
          jq -n --arg status "$ISSUES_ENABLED" '{issues_enabled: null, severity: "unknown", finding: ("Unable to determine issues status: " + $status)}'
        fi
      fi
    output: "issues_check"
    timeout: 30

  # ==========================================================================
  # STEP 8: Get Repository Stats
  # ==========================================================================
  - id: "get-repo-stats"
    type: "bash"
    parse_json: true
    command: |
      REPO="{{repo_owner}}/{{repo_name}}"
      
      # Get open PRs
      OPEN_PRS=$(gh pr list -R "$REPO" --state open --json number,title,author,createdAt,url 2>/dev/null || echo "[]")
      PR_COUNT=$(echo "$OPEN_PRS" | jq 'length')
      
      # Get recent commits (last 7 days) - handle both Linux and macOS date
      SINCE_DATE=$(date -d '7 days ago' -Iseconds 2>/dev/null || date -v-7d +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "2024-01-01T00:00:00Z")
      RECENT_COMMITS=$(gh api "repos/$REPO/commits?since=$SINCE_DATE" 2>/dev/null | jq 'length' || echo "0")
      
      # Get last push date - use heredoc to handle special characters
      cat << 'REPO_PUSH_EOF' > /tmp/repo_push_$$.json
      {{repo_info_raw}}
      REPO_PUSH_EOF
      LAST_PUSH=$(jq -r '.pushedAt // "unknown"' /tmp/repo_push_$$.json)
      rm -f /tmp/repo_push_$$.json
      
      jq -n \
        --argjson open_prs "$PR_COUNT" \
        --argjson recent_commits "${RECENT_COMMITS:-0}" \
        --arg last_push "$LAST_PUSH" \
        --argjson pr_details "$OPEN_PRS" \
        '{
          open_prs: $open_prs,
          recent_commits_7d: $recent_commits,
          last_push: $last_push,
          pr_details: $pr_details
        }'
    output: "repo_stats"
    timeout: 120
    retry:
      max_attempts: 2
      backoff: "linear"
      initial_delay: 3

  # ==========================================================================
  # STEP 9: Generate Audit Report (LLM generates content only)
  # ==========================================================================
  - id: "generate-report"
    agent: "foundation:zen-architect"
    mode: "ANALYZE"
    prompt: |
      Generate a comprehensive audit report for the repository. Return ONLY the markdown report content - do NOT write to any files.
      
      ## Repository Information
      
      - **Repository**: {{repo_owner}}/{{repo_name}}
      - **Validation**: {{repo_validation}}
      
      ## Audit Results
      
      ### 1. MODULES.md Listing
      {{modules_listing}}
      
      ### 2. Boilerplate Files Check
      {{boilerplate_check}}
      
      ### 3. README.md Sections Check
      {{readme_check}}
      
      ### 4. GitHub Issues Status
      {{issues_check}}
      
      ### 5. Repository Stats
      {{repo_stats}}
      
      ## Report Format
      
      Generate a markdown report following this structure:
      
      # Repository Audit Report: {{repo_owner}}/{{repo_name}}
      
      **Audit Date**: [use current date]
      **Repository URL**: https://github.com/{{repo_owner}}/{{repo_name}}
      
      ## Summary
      
      | Check | Status | Severity |
      |-------|--------|----------|
      | Listed in MODULES.md | [Pass/Fail/Recommendation] | [pass/warning/error/recommendation] |
      | CODE_OF_CONDUCT.md | [Match/Mismatch/Missing] | [pass/error] |
      | SECURITY.md | [Match/Mismatch/Missing] | [pass/error] |
      | SUPPORT.md | [Match/Mismatch/Missing] | [pass/error] |
      | LICENSE | [Match/Mismatch/Missing] | [pass/error] |
      | README Contributing | [Match/Mismatch/Missing] | [pass/warning/error] |
      | README Trademarks | [Match/Mismatch/Missing] | [pass/warning/error] |
      | GitHub Issues | [Disabled/Enabled] | [pass/recommendation] |
      
      **Overall Status**: [PASS / NEEDS ATTENTION / CRITICAL]
      - Critical issues (errors): N
      - Warnings: N  
      - Recommendations: N
      
      ## Detailed Findings
      
      [Provide details for each check, explaining what was found]
      
      ## Repository Activity
      
      - **Open PRs**: N
      - **Recent commits (7d)**: N
      - **Last push**: [date]
      
      [If there are open PRs, list them with titles and links]
      
      ## Remediation Steps
      
      [For each non-passing issue, provide specific steps to fix]
      
      ---
      *Generated by Amplifier repo-audit recipe v1.2.0*
    output: "audit_report_content"
    timeout: 300

  # ==========================================================================
  # STEP 10: Write Report to File (Bash - reliable file write)
  # ==========================================================================
  - id: "write-report"
    type: "bash"
    command: |
      set -euo pipefail
      REPORT_PATH="{{working_dir}}/{{repo_name}}/audit-report.md"
      mkdir -p "$(dirname "$REPORT_PATH")"
      
      cat << 'REPORT_CONTENT_EOF' > "$REPORT_PATH.tmp"
      {{audit_report_content}}
      REPORT_CONTENT_EOF
      
      mv "$REPORT_PATH.tmp" "$REPORT_PATH"
      echo "Report written: $REPORT_PATH ($(wc -c < "$REPORT_PATH") bytes)"
    output: "report_write_result"
    timeout: 30

  # ==========================================================================
  # STEP 11: Prepare Fix PR (Conditional)
  # ==========================================================================
  - id: "prepare-fixes"
    condition: "{{create_fix_pr}} == 'true' || {{dry_run}} == 'true'"
    agent: "foundation:zen-architect"
    mode: "ARCHITECT"
    prompt: |
      Analyze the audit findings and prepare fix recommendations. Return ONLY text output - do NOT write files.
      
      ## Audit Results
      
      Boilerplate check: {{boilerplate_check}}
      README check: {{readme_check}}
      
      ## Reference Files Location
      
      Reference files are available at: {{working_dir}}/reference/
      
      ## Tasks
      
      1. Identify which files need to be fixed based on the audit results
      
      2. For boilerplate files (CODE_OF_CONDUCT.md, SECURITY.md, SUPPORT.md, LICENSE):
         - List which ones need to be copied from reference
      
      3. For README.md sections:
         - Describe what sections need to be updated
         - Note that README content varies so manual integration is needed
      
      4. Create a PR description summarizing what needs to be fixed
      
      5. Provide shell commands that could be used to prepare the fixes
      
      Output a structured summary of what needs to be fixed and how.
    output: "fix_preparation"
    timeout: 300
    on_error: "continue"

  - id: "create-fix-instructions"
    condition: "{{create_fix_pr}} == 'true' || {{dry_run}} == 'true'"
    type: "bash"
    command: |
      REPO="{{repo_owner}}/{{repo_name}}"
      TARGET_DIR="{{working_dir}}/{{repo_name}}"
      REF_DIR="{{working_dir}}/reference"
      FIXES_DIR="$TARGET_DIR/fixes"
      DRY_RUN="{{dry_run}}"
      CREATE_PR="{{create_fix_pr}}"
      
      mkdir -p "$FIXES_DIR"
      
      # Copy non-matching boilerplate files to fixes dir
      BOILERPLATE='{{boilerplate_check}}'
      FILES_TO_FIX=""
      for file in CODE_OF_CONDUCT.md SECURITY.md SUPPORT.md LICENSE; do
        STATUS=$(echo "$BOILERPLATE" | jq -r --arg f "$file" '.files[] | select(.name == $f) | .severity')
        if [ "$STATUS" = "error" ]; then
          cp "$REF_DIR/$file" "$FIXES_DIR/$file"
          FILES_TO_FIX="$FILES_TO_FIX $file"
          echo "Prepared fix: $file"
        fi
      done
      
      # Create PR instructions/preview
      if [ "$DRY_RUN" = "true" ]; then
        echo ""
        echo "========================================"
        echo "DRY-RUN: PR PREVIEW for $REPO"
        echo "========================================"
        echo ""
        if [ -z "$FILES_TO_FIX" ]; then
          echo "âœ“ No fixes needed - all boilerplate files match"
        else
          echo "Files that WOULD be fixed:"
          for f in $FILES_TO_FIX; do
            echo "  - $f"
          done
          echo ""
          echo "PR that WOULD be created:"
          echo "  Title: fix: Compliance audit fixes for Microsoft OSS standards"
          echo "  Branch: fix/compliance-audit-fixes"
          echo "  Body: Fixes identified by Amplifier repo-audit recipe"
          echo ""
          echo "Fix files prepared at: $FIXES_DIR"
        fi
        echo ""
        echo "[DRY-RUN MODE - No PR was created]"
        echo "========================================"
      fi
      
      # Create PR instructions file
      cat << 'PR_INSTRUCTIONS' > "$TARGET_DIR/pr-instructions.md"
      # Fix PR Instructions for {{repo_owner}}/{{repo_name}}
      
      ## Steps to Create Fix PR
      
      1. Clone the repository:
         ```bash
         git clone https://github.com/{{repo_owner}}/{{repo_name}}.git
         cd {{repo_name}}
         ```
      
      2. Create a branch:
         ```bash
         git checkout -b fix/compliance-audit-fixes
         ```
      
      3. Copy fixed files from: {{working_dir}}/{{repo_name}}/fixes/
      
      4. Commit and push:
         ```bash
         git add .
         git commit -m "fix: compliance audit fixes for Microsoft OSS standards"
         git push origin fix/compliance-audit-fixes
         ```
      
      5. Create PR via GitHub UI or:
         ```bash
         gh pr create --title "fix: Compliance audit fixes" --body "Fixes identified by Amplifier repo-audit recipe"
         ```
      PR_INSTRUCTIONS
      
      echo "Fix instructions written to: $TARGET_DIR/pr-instructions.md"
      ls -la "$FIXES_DIR" 2>/dev/null || echo "No fix files generated (all checks may have passed)"
    output: "pr_creation_result"
    timeout: 120
    on_error: "continue"

  # ==========================================================================
  # STEP 12: Final Summary
  # ==========================================================================
  - id: "final-summary"
    type: "bash"
    command: |
      REPORT_PATH="{{working_dir}}/{{repo_name}}/audit-report.md"
      
      echo "========================================"
      echo "AUDIT COMPLETE: {{repo_owner}}/{{repo_name}}"
      echo "========================================"
      echo ""
      echo "Report: $REPORT_PATH"
      echo ""
      
      if [ -f "$REPORT_PATH" ]; then
        cat "$REPORT_PATH"
      else
        echo "ERROR: Report file not found"
        exit 1
      fi
    output: "final_output"
    timeout: 30
