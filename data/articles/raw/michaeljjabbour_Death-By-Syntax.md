---
title: Death By Syntax
author: michaeljjabbour
date: 
source: https://michaeljjabbour.substack.com/p/death-by-syntax
publication: michaeljjabbour
---

# Death By Syntax

*Speaking human to machines*

Breaking the Barrier

You don't have to be a programmer anymore. You don't need to memorize grammar rules in four languages, learn the secret handshakes of semicolons and curly braces. The boundary that once felt absolute—that mastery of technical form was the price of admission to creation—is dissolving.

I spent twenty-eight years believing otherwise, collecting languages like scars. Pascal's rigid declarations. Ruby's deceptive simplicity. JavaScript's beautiful chaos. Arabic's shape-shifting letters. Hebrew's missing vowels. Chinese's tonal acrobatics. Each one a gatekeeper demanding years of tribute before letting me create anything worthwhile.

Then GPT-3.5 arrived and wrote quality code in every language I'd bled to learn. In that moment, I thought I was witnessing my own obsolescence.

I was wrong. I was witnessing liberation.

The Old Temple of Syntax

1997: The computer lab smelled like static and ambition. Novell NetWare ran our network—red screens and cryptic commands. We learned BASIC because that's what you learned first, Pascal because that's what computer science meant, and NetWare commands because someone had to keep the network alive.

By 2005, I'd moved through C#, picked up Ruby because it promised to "make programmers happy." Except happiness still required memorizing whether it's.eachor.forEachor.map. The syntax had gotten friendlier, but it was still a wall.

2015: Learning Chinese while debugging JavaScript. Both languages lying to me in different ways. Chinese: same sound, four tones, four completely different meanings. JavaScript: same operator, different contexts, completely different behaviors.

We were all prisoners of form. The idea in your head—that app, that story, that solution—held hostage by your ability to speak machine.

When the Walls Came Down

Recently at a workshop, I watched a 72-year-old retired city planner build an app. Never wrote a line of code. But she understood urban mobility like few others.

"I need an app that shows safe walking routes with rest points for seniors," she explained to the AI. "Factor in shade during summer, snow clearance in winter, and proximity to public restrooms."

Ten minutes later: working prototype. Map integration. Seasonal adjustments. Community reporting features. Route optimization for different mobility levels.

She didn't know it used React, PostgreSQL, or that the routing algorithm was a modifiedDijkstra's shortest path. She didn't need to. She knew what mattered: how cities fail their aging populations.

The NetWare Generation's Advantage

Those of us who learned on NetWare, who remember when networks were physical things you could trace with your fingers, we might have an odd advantage. We understand systems thinking. We debugged by elimination. We learned that everything connects to everything else.

But we also learned the wrong lesson: that technical mastery was mandatory. That you couldn't contribute without first spending years learning the incantations.

A colleague from those days now runs a medical clinic. Last month, he built a diagnostic assistant that catches drug interactions his younger doctors miss. Not because he learned Python—he didn't. Because he explained to AI what twenty years of practice taught him: "When elderly patients say they're 'tired,' check these seven medication combinations first."

His tool can now regularly prevent adverse events. The syntax didn't matter. The pattern recognition did.

Everyday Magic: The New Creators

The Arabic translator who built a tool that preserves emotional nuance when converting between dialects. She never learned programming. She taught AI that "يا حبيبي" means something different in Egyptian versus Lebanese contexts—not just linguistically, but culturally.1

The music teacher who creates software that identifies when students are playing notes correctly but without confidence. "The hesitation between C and D tells you more than the wrong note," he explained. No audio engineering degree. Just decades of hearing fear in fingertips.

The former network admin who now builds network visualization tools by describing what he used to draw on whiteboards. "Show me the choke points, the redundant paths, the forgotten connections that only activate during failures."

These aren't programmers becoming creative. These are experts finally able to externalize their expertise.2

What Dies, What Lives

The Human Differentiator

If machines handle syntax, what's left for us? Everything that matters.

Vision Over Vocabulary: The city planner didn't need to know "geospatial databases." She needed to know that elderly people plan walks around bathroom availability. That's not syntax—that's wisdom.

Context Over Code: A Chinese colleague explained: "AI speaks perfect Mandarin, but doesn't know that government documents require a specific formal register that no textbook teaches. That institutional knowledge—that's not programmable. That's lived."

Purpose Over Perfection: I watch new developers obsess over clean code while missing the point. Your users don't care if you used tabs or spaces. They care if your app solves their problem.

The NetWare Lesson, Revisited

Those NetWare screens taught us something valuable: systems thinking. Everything connects. Change one thing, affect another. That mental model matters more now than ever.

But we learned the wrong corollary: that you needed to understand every connection to contribute. That's the lie. You need to understand YOUR connections—your domain, your expertise, your specific knowledge.

The AI handles the rest.

The New Workshop Reality

I run workshops differently now. No "Hello World." We start with "What world needs help?"

A supply chain manager wanted to predict shortages before they happened. Thirty years of experience told her which patterns preceded problems. She didn't learn SQL. She taught AI her mental model: "When three suppliers in the same region go quiet simultaneously, check for local holidays, weather events, or political changes."

Her tool could save her company far more than pocket change—not through code mastery, but through pattern mastery.

A therapist built an intake system that spots crisis indicators other systems miss. "When someone describes their sleep pattern with too much precision, they're often masking deeper issues." No psychology AI could deduce that. Thirty years of listening could.

How to Start Creating Today

Forget your technical limitations. Start with your expertise. What do you know that machines don't? What patterns do you see that aren't in any manual?

Describe problems like you're explaining to a smart colleague who knows nothing about your field. Use your jargon, your shortcuts, your tribal knowledge. That specialized understanding is your programming language now.

Start with the problem, not the solution. "I need to track X because Y happens when Z" is better than "I need a database with these fields."

Build ugly first. Every beautiful app started hideous. Function before form. Solution before style.

The Death That's Actually Birth

The death of syntax isn't the death of craft. It's the death of unnecessary gatekeeping. The end of "learn our language before you can solve problems."

A grandfather who was a carpenter whose arthritis stole his ability to build. Today, he could describe his designs—in words, sketches, even humming the feeling he wanted—and machines would handle the CAD files,the CNC code, the joint calculations. His expertise wouldn't be trapped in failing hands.

That's what dies with syntax: brilliant solutions dying unexpressed. The nurse who sees the pattern but can't code. The teacher who knows the fix but can't build. The immigrant with the innovation who can't write it in their third language.

The Pascal Programmer's Paradox

Those of us who learned Pascal in 1997, who debugged NetWare, who wrote BASIC because that's what you did—we're perfectly positioned for this moment. Not because of our syntax knowledge (mostly obsolete) but because we learned to think systematically.

We understand that computers are stupid. Brilliantly fast, but stupid. We learned that the hard way, one syntax error at a time. That understanding—that computers need explicit instruction—makes us better at instructing AI. We know what clarity looks like because we've debugged its absence.

But we also need to unlearn. To stop believing that technical fluency is the entry fee. To stop gatekeeping ourselves.

Your Beautiful Broken Future

We're entering an age where broken becomes beautiful. Where your struggle with systems qualifies you to redesign them. Where your frustration with existing tools makes you the perfect architect of better ones.

The future doesn't care about your syntax. It cares about your vision.

A colleague asked me last week: "If AI can code everything, why did we spend decades learning?"

"Because someone had to build the bridge," I told him. "We were the generation that translated human need into machine language manually. Now we're the generation that teaches machines to build their own bridges."

We didn't waste those years. We were the necessary step. The NetWare generation, the syntax programmers, the people who debugged by printout—we were syntax's last generation and meaning's first.

The machines handle the how. We handle the why. Together, we build the what.

The syntax is almost dead.

Long live the creators.

“يا حبيبي” (ya ḥabibi) literally means “my beloved.” In Egyptian Arabic, it’s often used casually, like “buddy” or “pal,” while in Lebanese Arabic it usually carries deeper, more intimate or affectionate meaning. The difference is not just in language, but in culture and context.

Safety Note:The death of syntax doesn't mean the death of standards. Security, reliability, and user protection remain non-negotiable. Democratizing creation means more people should be asking more critical questions, not fewer. Every prototype that touches real users needs rigorous verification—the difference is that now domain experts can demonstrate what's needed, then partner with specialists to make it production-ready. Well-trained AIs might soon surpass humans at diagnosis and security checks, but that doesn't reduce our responsibility to ensure these creations are safe.
